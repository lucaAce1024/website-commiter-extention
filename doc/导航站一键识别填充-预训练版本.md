# 导航站一键识别填充设计文档（预训练版本）

## 一、目标与约束

- **最终体验**：用户点击一个按钮，**一键填充**当前提交页所有需要填充的字段，且**速度尽量快**（目标 3s 内完成填充）。
- **填充方式**：
  - **文本类**（网站名称、邮箱、URL、描述等）：直接写入/粘贴到输入框。
  - **文件上传**（Logo、界面截图）：由插件协助完成——在支持的环境下通过 DataTransfer 等写入，否则通过「点击上传控件」打开文件选择器，由用户选择已准备好的文件或由自动化工具注入。
- **识别方式**：
  - **预训练**：事先对所有目标导航站提交页做一次「预览/抓取」，用 ML 或 HTML 分析工具梳理出「页面 → 字段绑定关系」，存成映射表；用户打开页面时直接查表填充。

---

## 二、整体流程

| 阶段     | 步骤 | 说明 |
|----------|------|------|
| **识别（离线）** | 1. 获取页面表单结构 | 批量抓取目标导航站提交页的 HTML / DOM / 结构化表单描述。 |
|          | 2. 得到字段映射     | 得到「标准字段 → 元素定位」的映射（standardField → locator）。 |
| **填充（运行时）** | 3. 按映射定位元素   | 根据 locator 在页面上找到每个输入控件。 |
|          | 4. 填充文本         | 对 input/textarea/contenteditable 等写入站点档案中的文本。 |
|          | 5. 处理文件上传     | 对 Logo/截图：能程序写入则写入，否则触发点击由用户或自动化选文件。 |

**预训练方案**中，步骤 1–2 在「离线/批量」阶段完成，结果存成映射表；用户点击「一键填充」时只做 3–5，直接查表填充，**速度最快**。

---

## 三、预训练方案：步骤、技术与取巧

### 3.1 思路简述

事先把「需要点击的导航站」的提交页**全部访问一遍**（或批量抓取），用**机器学习**或**HTML/表单分析工具**从页面中提取表单结构，并推断每个控件对应的标准字段，形成「URL（或 domain+path）→ 映射表」。用户日后打开其中任意一个 URL，直接查表得到映射，只做填充，不做识别。

### 3.2 步骤拆解与技术选型

| 步骤 | 做什么 | 可选技术 | 说明 |
|------|--------|----------|------|
| **1. 提交页列表** | 确定要预处理的导航站提交 URL | 用户维护的 navSites、或配置文件、或爬虫入口 | 列表即「种子 URL」，可存于扩展 storage 或外部服务。 |
| **2. 页面获取** | 对每个 URL 拿到「可用的」表单 DOM | **Playwright / Puppeteer**（推荐）、或扩展内开 tab 再注入脚本 | 必须执行 JS，很多站是 SPA；Headless 可批量、可脚本化。 |
| **3. 结构抽取** | 从 DOM 生成紧凑的表单描述（便于学习） | **DOM API + 自定义序列化**、或 **Playwright 的 accessibility snapshot**、或 **简化 HTML** | 输出：每个控件的 tag、type、name、id、placeholder、label、aria-label、在表单中的顺序、可选 XPath/CSS selector。 |
| **4. 字段映射推断** | 为每个控件打上「标准字段」标签（siteName、email、siteUrl…） | **规则+关键词**（现有 keyword/regex）、**ML 分类器**、或**单次调用 LLM 做批量标注** | 规则：快、可解释；ML：需标注数据；LLM：一次请求可处理整页，准确率高但需 API。 |
| **5. 存储** | 保存「URL 或 cacheKey → mappings」 | **chrome.storage**、或**外部 API/DB**（站点很多时） | 扩展内优先 storage；存储结构建议带 version 与 updatedAt，便于兼容与失效策略。 |
| **6. 运行时查表** | 用户打开某提交页并点击「一键填充」时 | 用 **cacheKey = domain + pathname** 查存储 | 命中则跳过识别，直接进入填充。 |

### 3.3 预训练中的「取巧」方式

- **用 LLM 做一次性批量标注（预训练阶段）**：对每个提交页只调一次 API，把整页的「表单结构文本」发给 LLM，让它返回「fieldIndex → standardField」或「selector → standardField」。这样不需要自己标注训练集，也能得到较准的映射，且**预训练阶段**的延迟用户无感。
- **只序列化表单区域**：不送整页 HTML，只送 `<form>` 及其内部节点（或按选择器截断），减少 token、提高解析稳定性。
- **规则优先 + LLM 兜底**：先用现有 keyword/正则跑一遍，只对「未匹配或低置信度」的字段再调 LLM，降低 API 调用次数。
- **增量更新**：预训练结果按 URL 存；新增导航站时只对新 URL 跑一遍 2–5，不影响已有缓存。

---

## 四、填充阶段：文本 vs 文件、技术与取巧

### 4.1 文本内容：直接写入

- **做法**：对 input/textarea/contenteditable，用现有逻辑：`value` 赋值 + `input`/`change` 事件；富文本/CodeMirror/ProseMirror 等已有分支。
- **技术**：Content script 内 `fillInputElement` / `fillContentEditable`，无需额外技术。
- **取巧**：
  - **减少字段间延迟**：在保证下拉/联动稳定的前提下，把 `FILL_FIELD_DELAY_MS` 按字段类型区分（普通 input 可更短，自定义下拉/富文本略长）。
  - **批量 dispatch**：同一表单内多个简单 input 可连续赋值后再统一 dispatch 事件，减少重排次数（需验证目标站点无依赖「逐字段失焦」的逻辑）。

### 4.2 文件上传：点击上传 + 能写则写

- **现状**：扩展内已通过 **DataTransfer + File 对象**（`fillFileInputWithDataUrl`）尝试写入 `input.files`；在部分站点/浏览器下可用。
- **限制**：出于安全策略，部分环境禁止脚本直接设置 `input[type=file].files`，此时只能「帮助用户点击」。
- **可选技术**：
  - **可写时**：继续用 DataTransfer 将站点档案中的 Logo/截图（data URL 转 File）写入 file input，并触发 `input`/`change`。
  - **不可写时**：由插件**模拟点击**上传控件，打开系统文件选择器；用户从本地选择已准备好的文件，或由**外部自动化**（Playwright/Puppeteer 的 FileChooser）在非扩展环境中注入文件。
- **取巧**：
  - 优先尝试 DataTransfer；写入后检查 `input.files.length` 等以确认是否生效，未生效则立即走「点击上传」并明确提示用户选择文件。

---

## 五、整体步骤汇总

| 序号 | 阶段 | 步骤 | 预训练方案 |
|------|------|------|------------|
| 1 | 识别（离线） | 获取表单结构 | 批量用 Playwright 等抓取并序列化 |
| 2 | 识别（离线） | 得到字段映射 | 规则/ML/单次 LLM 批量标注，写入存储 |
| 3 | 填充（运行时） | 定位元素 | 查表得到 mappings，在页面上 resolve |
| 4 | 填充（运行时） | 填文本 | 按标准字段取站点数据，写入控件 |
| 5 | 填充（运行时） | 文件上传 | DataTransfer 或点击上传 |

**步骤总数**：识别 2 步（离线）+ 填充 3 步（运行时），共 **5 步**；用户端只感知「查表 + 填充 3 步」，**速度最快**。

---

## 六、易用性、可维护性与实现复杂度

### 6.1 易用性

| 维度 | 设计要点 | 说明 |
|------|----------|------|
| **结果可见性** | 填充完成后给出明确反馈 | 如：「已填充 8/10 项；Logo、截图需您手动选择文件」；失败字段列出并支持「重试」或「手动填写」。 |
| **部分成功** | 支持部分字段填充成功、部分失败 | 不因单字段失败阻断整页；未识别或写入失败的字段可高亮或列在「待补全」列表，用户可手动补填。 |
| **降级说明** | 文件上传不可写时的提示 | 当 DataTransfer 不可用时，明确提示「请点击上传按钮并选择文件」，避免用户误以为未执行。 |
| **可覆盖** | 用户可纠正错误映射 | 若某站自动把「描述」填到了错误输入框，支持用户「点选绑定字段」修正一次并写回缓存，下次优先用用户修正结果。 |

### 6.2 可维护性

| 维度 | 设计要点 | 说明 |
|------|----------|------|
| **映射表结构** | 统一 schema + 版本号 | 存储格式约定为 `{ version: 1, cacheKey, mappings: [{ standardField, locator }], updatedAt? }`，便于后续扩展字段或 locator 类型时做兼容与迁移。 |
| **缓存失效** | 页面结构变更时能更新 | 若检测到页面 DOM 与缓存中记录的表单结构差异过大（如关键 selector 失效），可自动标记该 cacheKey 失效并回退「重新识别」。 |
| **预训练归属** | 明确谁跑、在哪跑 | 预训练流水线建议：Node 脚本 + 配置文件（navSites 列表），可在 CI 或本机定期执行；扩展仅消费「预训练结果」（从 storage 或服务端按 URL 拉取），不负责批量抓取本身，降低扩展复杂度。 |
| **配置集中** | 延迟、超时、开关集中管理 | 将 `FILL_FIELD_DELAY_MS` 等收拢到单一配置（如 `fillConfig`），便于调优。 |

### 6.3 技术实现复杂度控制

| 维度 | 设计要点 | 说明 |
|------|----------|------|
| **表单序列化格式** | 约定单一「紧凑表示」规范 | 输出每个控件的 id/name/type/label/placeholder/aria-label + 顺序，便于复用解析。 |
| **文件写入检测** | 明确 DataTransfer 是否生效 | 写入 file input 后检查 `input.files.length` 等；若仍为 0 则视为不可写，立即走「点击上传 + 提示用户选文件」，避免静默失败。 |

---

## 七、推荐落地顺序

- **短期**：完善**规则+关键词识别**，建立映射表存储机制（cacheKey = domain + pathname），实现**点选绑定字段**功能供用户纠正错误映射。
- **中期**：若导航站列表固定且较多，可增加**预训练流水线**：用 Playwright 批量打开提交页，每页调一次 LLM（或规则）生成映射并写入存储。
- **取巧优先级**：
  1. **缓存**（domain + pathname）—— 识别只做一次。
  2. **精简预处理内容**—— 只处理 form 内字段描述，提高效率。
  3. **填充阶段**—— 区分字段类型缩短延迟、文件优先 DataTransfer 再点击上传。

按上述规划即可实现「点击一个按钮、一键填充所有字段、且尽量快」的目标。
