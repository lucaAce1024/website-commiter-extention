# 导航站一键识别填充设计文档

## 一、目标与约束

- **最终体验**：用户点击一个按钮，**一键填充**当前提交页所有需要填充的字段，且**速度尽量快**（目标 3s 内完成识别+填充）。
- **填充方式**：
  - **文本类**（网站名称、邮箱、URL、描述等）：直接写入/粘贴到输入框。
  - **文件上传**（Logo、界面截图）：由插件协助完成——在支持的环境下通过 DataTransfer 等写入，否则通过「点击上传控件」打开文件选择器，由用户选择已准备好的文件或由自动化工具注入。
- **识别方式**（二选一或混合）：
  - **预训练**：事先对所有目标导航站提交页做一次「预览/抓取」，用 ML 或 HTML 分析工具梳理出「页面 → 字段绑定关系」，存成映射表；用户打开页面时直接查表填充。
  - **接入 AI**：打开页面后，用大模型理解当前页 HTML，提取需要填充的字段及其定位信息，再执行填充。

下文按「整体步骤 → 预训练方案 → AI 方案 → 填充与加速」展开，并给出每步的技术选型与取巧方式。

---

## 二、整体流程需要多少步？

无论采用预训练还是 AI，**端到端**可归纳为以下步骤：

| 阶段     | 步骤 | 说明 |
|----------|------|------|
| **识别** | 1. 获取页面表单结构 | 拿到当前页（或预抓取页）的 HTML / DOM / 结构化表单描述。 |
|          | 2. 得到字段映射     | 得到「标准字段 → 元素定位」的映射（standardField → locator）。 |
| **填充** | 3. 按映射定位元素   | 根据 locator 在页面上找到每个输入控件。 |
|          | 4. 填充文本         | 对 input/textarea/contenteditable 等写入站点档案中的文本。 |
|          | 5. 处理文件上传     | 对 Logo/截图：能程序写入则写入，否则触发点击由用户或自动化选文件。 |

**预训练方案**中，步骤 1–2 在「离线/批量」阶段完成，结果存成映射表；用户点击「一键填充」时只做 3–5，必要时再查表。  
**AI 方案**中，步骤 1–2 在用户点击后实时执行（或先查缓存再决定是否调 AI），然后执行 3–5。

---

## 三、预训练方案：步骤、技术与取巧

### 3.1 思路简述

事先把「需要点击的导航站」的提交页**全部访问一遍**（或批量抓取），用**机器学习**或**HTML/表单分析工具**从页面中提取表单结构，并推断每个控件对应的标准字段，形成「URL（或 domain+path）→ 映射表」。用户日后打开其中任意一个 URL，直接查表得到映射，只做填充，不做识别。

### 3.2 步骤拆解与技术选型

| 步骤 | 做什么 | 可选技术 | 说明 |
|------|--------|----------|------|
| **1. 提交页列表** | 确定要预处理的导航站提交 URL | 用户维护的 navSites、或配置文件、或爬虫入口 | 列表即「种子 URL」，可存于扩展 storage 或外部服务。 |
| **2. 页面获取** | 对每个 URL 拿到「可用的」表单 DOM | **Playwright / Puppeteer**（推荐）、或扩展内开 tab 再注入脚本 | 必须执行 JS，很多站是 SPA；Headless 可批量、可脚本化。 |
| **3. 结构抽取** | 从 DOM 生成紧凑的表单描述（便于学习或送 LLM） | **DOM API + 自定义序列化**、或 **Playwright 的 accessibility snapshot**、或 **简化 HTML** | 输出：每个控件的 tag、type、name、id、placeholder、label、aria-label、在表单中的顺序、可选 XPath/CSS selector。 |
| **4. 字段映射推断** | 为每个控件打上「标准字段」标签（siteName、email、siteUrl…） | **规则+关键词**（现有 keyword/regex）、**ML 分类器**、或**单次调用 LLM 做批量标注** | 规则：快、可解释；ML：需标注数据；LLM：一次请求可处理整页，准确率高但需 API。 |
| **5. 存储** | 保存「URL 或 cacheKey → mappings」 | **chrome.storage**、或**外部 API/DB**（站点很多时） | 扩展内优先 storage；映射条数很大时可放服务端，扩展按 URL 查询。 |
| **6. 运行时查表** | 用户打开某提交页并点击「一键填充」时 | 用 **cacheKey = domain + pathname** 查存储 | 命中则跳过识别，直接进入填充；未命中可回退「规则识别」或「AI 识别」。 |

### 3.3 预训练中的「取巧」方式

- **用 LLM 做一次性批量标注（预训练阶段）**：对每个提交页只调一次 API，把整页的「表单结构文本」发给 LLM，让它返回「fieldIndex → standardField」或「selector → standardField」。这样不需要自己标注训练集，也能得到较准的映射，且**预训练阶段**的延迟用户无感。
- **只序列化表单区域**：不送整页 HTML，只送 `<form>` 及其内部节点（或按选择器截断），减少 token、提高解析稳定性。
- **规则优先 + LLM 兜底**：先用现有 keyword/正则跑一遍，只对「未匹配或低置信度」的字段再调 LLM，降低 API 调用次数。
- **增量更新**：预训练结果按 URL 存；新增导航站时只对新 URL 跑一遍 2–5，不影响已有缓存。

---

## 四、接入 AI 方案：步骤、技术与取巧

### 4.1 思路简述

用户打开某个导航站提交页并点击「一键填充」时，**实时**从当前页抽取表单信息，送给**大模型**理解，让模型输出「需要填充的字段 + 定位方式」（如 id、name、XPath），再在页面内按定位执行填充。文本直接写入，文件上传通过现有 DataTransfer 或点击上传控件配合用户/自动化完成。

### 4.2 步骤拆解与技术选型

| 步骤 | 做什么 | 可选技术 | 说明 |
|------|--------|----------|------|
| **1. 抽取表单结构** | 在 content script 中拿到当前页表单的紧凑表示 | **仅序列化 form**（或主表单容器）、**限制深度与属性长度** | 避免整页 `outerHTML`，控制 token 与噪音。 |
| **2. 调用大模型** | 把结构发给 LLM，要求返回「标准字段 + 定位」 | **OpenAI / 兼容 API**（现有 llmService）、**本地模型（Ollama 等）**、**结构化输出（JSON）** | 与现有 `buildLLMPrompt` / `parseLLMMapping` 对齐，可扩展为「返回 locator」。 |
| **3. 解析并规范化** | 从模型输出解析出 (standardField, locator) | **JSON mode**、**正则/括号匹配** 提取 JSON | 统一成扩展内部的 locator 格式（id / name+formIndex / xpath）。 |
| **4. 缓存** | 同一 URL 再次访问时避免重复调 API | **cacheKey = domain + pathname** 存 mapping | 第二次起「识别」耗时≈0。 |
| **5. 填充** | 与预训练方案共用同一套填充逻辑 | 见第五节 | 文本直接写入；文件用 DataTransfer 或点击上传。 |

### 4.3 AI 方案的「取巧」方式

- **精简输入**：只送表单内 input/textarea/select + 直接关联的 label/placeholder/aria-label，去掉无关 DOM，显著减少 token 与延迟。
- **固定输出格式**：要求模型严格输出 JSON，例如 `[{"standardField":"email","selector":"#email"}]`，便于解析且减少重试。
- **先查缓存再调 AI**：每次先查 `cacheKey`；命中则直接用缓存映射，不调 API，实现「第一次 AI、后续秒填」。
- **可选：规则预筛**：先跑一遍规则识别，只有「无缓存且规则未完全匹配」时才调 AI，进一步省成本、省时间。
- **超时与降级**：AI 请求设 5–10s 超时；超时或失败时回退到规则识别，保证至少能填一部分。

---

## 五、填充阶段：文本 vs 文件、技术与取巧

### 5.1 文本内容：直接写入

- **做法**：对 input/textarea/contenteditable，用现有逻辑：`value` 赋值 + `input`/`change` 事件；富文本/CodeMirror/ProseMirror 等已有分支。
- **技术**：Content script 内 `fillInputElement` / `fillContentEditable`，无需额外技术。
- **取巧**：
  - **减少字段间延迟**：在保证下拉/联动稳定的前提下，把 `FILL_FIELD_DELAY_MS` 按字段类型区分（普通 input 可更短，自定义下拉/富文本略长）。
  - **批量 dispatch**：同一表单内多个简单 input 可连续赋值后再统一 dispatch 事件，减少重排次数（需验证目标站点无依赖「逐字段失焦」的逻辑）。

### 5.2 文件上传：点击上传 + 能写则写

- **现状**：扩展内已通过 **DataTransfer + File 对象**（`fillFileInputWithDataUrl`）尝试写入 `input.files`；在部分站点/浏览器下可用。
- **限制**：出于安全策略，部分环境禁止脚本直接设置 `input[type=file].files`，此时只能「帮助用户点击」。
- **可选技术**：
  - **可写时**：继续用 DataTransfer 将站点档案中的 Logo/截图（data URL 转 File）写入 file input，并触发 `input`/`change`。
  - **不可写时**：由插件**模拟点击**上传控件，打开系统文件选择器；用户从本地选择已准备好的文件，或由**外部自动化**（Playwright/Puppeteer 的 FileChooser）在非扩展环境中注入文件。
- **取巧**：
  - 优先尝试 DataTransfer；失败再走「点击上传」并提示用户选择文件。
  - 若使用「预训练」或「AI + 缓存」，第二次起无需再识别，**只做填充**，文件上传部分与首次一致，整体仍是一键完成。

---

## 六、整体步骤汇总（便于实现拆任务）

| 序号 | 阶段 | 步骤 | 预训练方案 | AI 方案 | 共用 |
|------|------|------|------------|---------|------|
| 1 | 识别 | 获取表单结构 | 批量用 Playwright 等抓取并序列化 | Content 序列化当前页 form | 结构格式一致更利复用 |
| 2 | 识别 | 得到字段映射 | 规则/ML/单次 LLM 批量标注，写入存储 | 实时调 LLM，解析出 mappings，并写入缓存 | 存储格式：cacheKey → mappings |
| 3 | 填充 | 定位元素 | 查表得到 mappings，在页面上 resolve | 同左 | findElementByLocator |
| 4 | 填充 | 填文本 | 按标准字段取站点数据，写入控件 | 同左 | fillInputElement / fillContentEditable |
| 5 | 填充 | 文件上传 | DataTransfer 或点击上传 | 同左 | fillFileInputWithDataUrl 或 click + 用户选文件 |

**步骤总数**：识别 2 步 + 填充 3 步，共 **5 步**；预训练把前 2 步提前到离线，用户端只感知「查表 + 填充 3 步」。

---

## 七、推荐组合与落地顺序

- **短期**：以 **AI 方案**为主，复用现有 LLM 能力；加强「表单结构精简 + 缓存（cacheKey = domain + pathname）」和「解析失败时回退规则」，这样**一次点击即可**完成识别+填充，第二次同一页秒填。
- **中期**：若导航站列表固定且较多，可增加**预训练流水线**：用 Playwright 批量打开提交页，每页调一次 LLM（或规则）生成映射并写入存储；扩展内优先查该映射表，未命中再实时 AI，兼顾速度与覆盖率。
- **取巧优先级**：
  1. **缓存**（domain + pathname）—— 识别只做一次。
  2. **精简送 LLM 的内容**—— 只送 form 内字段描述，缩短延迟与成本。
  3. **填充阶段**—— 区分字段类型缩短延迟、文件优先 DataTransfer 再点击上传。

按上述规划即可实现「点击一个按钮、一键填充所有字段、且尽量快」的目标；预训练与 AI 可并存，由配置或策略决定优先用表还是用实时 AI。
