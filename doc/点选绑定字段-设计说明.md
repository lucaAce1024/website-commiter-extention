# 「在页面上点选绑定」字段 — 设计说明

## 一、目标与原则

- **一次配置、后续无限复用**：用户在某个提交页上对需要绑定的输入框做一次「右键 → 绑定为某字段」，插件保存该页的映射；之后同一页面（同 domain + path）自动用这份映射识别与填充。
- **配置足够简单**：用户**不写、不看** element path，只做两件事：在输入框上右键 → 选择「绑定为 [网站名称]」等。path 由插件从当前点击元素自动生成并存储。
- **与现有能力兼容**：与现有「填充单个字段」右键菜单并存；绑定结果与现有缓存结构兼容，并支持「先自动识别，再按需纠错绑定」的混合用法。

---

## 二、用户流程（细化）

### 2.1 典型流程：首次使用某提交页

1. 用户打开某个导航站的「提交网站」页面（例如 `https://nav.example.com/submit`）。
2. 可选：点击插件「识别并填充」先做一次自动识别与填充。
3. 若某字段识别错或未识别，用户在该**输入框上右键**。
4. 在右键菜单中展开 **「绑定为字段 (外链提交助手)」** → 选择对应标准字段（如「网站名称」「联系邮箱」「网站 URL」等）。
5. 插件提示「已绑定：网站名称」（或类似），并将该元素与所选标准字段的映射写入**当前页的缓存**（key = 当前 domain + path）。
6. 用户可继续对其它输入框重复步骤 3–5；也可直接再次点击「识别并填充」，此时会优先使用刚绑定的映射（见下文「读取与合并」）。
7. 下次用户再打开 **同一 URL**（同一 domain + path），插件直接使用已保存的映射，无需再次绑定。

### 2.2 纠错流程（自动识别后）

- 自动识别并填充后，若「网站 URL」填到了错误的输入框：用户在该**错误输入框**上右键 → 「绑定为字段」→「网站 URL」。插件会**用新元素覆盖**该页面上「网站 URL」的原有映射（无论是之前自动识别的还是之前绑定的），并写回缓存。

### 2.3 可选：解除绑定（后续扩展）

- 若将来需要「取消某标准字段在本页的绑定」，可在右键菜单增加「解除绑定」→ 选择要解除的字段，从当前页的映射中移除该项（仍可保留自动识别得到的其它字段）。

---

## 三、缓存键与存储结构

### 3.1 缓存键：domain + pathname（内部细化，用户无感）

- **当前**：缓存仅按 `domain`（hostname）存储，同一域名下不同路径共用一个 key，容易误用。
- **调整**：缓存 key 改为 **`cacheKey = domain + pathname`**，并对 pathname 做简单规范化（见下）。用户界面不暴露「path」概念，只感知「这个页面已经配置好了」。
- **规范化建议**：  
  - `pathname` 去掉末尾斜杠，例如 `/submit` 与 `/submit/` 视为同一页；  
  - 或统一用 `pathname.replace(/\/$/, '') || '/'`，保证根路径为 `'/'`。  
- **向后兼容**：  
  - 读取时：先用 `cacheKey` 查；若无，再用 `domain` 查（兼容旧数据）。  
  - 写入时：新绑定 / 新识别结果一律按 `cacheKey` 写入；旧 key 可保留不删，避免影响其它未升级的安装。

### 3.2 单条映射的数据结构（与现有一致）

与现有 `fieldMappings` 中单条一致，便于复用 `findElementByLocator` 与填充逻辑：

```ts
{
  standardField: 'siteName' | 'email' | 'siteUrl' | 'category' | 'tags' | 'tagline' | 'shortDescription' | 'longDescription' | 'logo' | 'screenshot',
  locator: { type: 'id'|'name'|'data'|'index'|'xpath', value: string, formIndex?: number, ... },
  xpath?: string,
  locatorDesc?: string,
  method?: 'bind' | 'keyword' | 'cache'   // 可选，用于区分来源；填充逻辑不依赖此项
}
```

- **locator**：由 content 里现有的 `getFieldLocator(element)` 生成，优先 id → name+formIndex → data-* → index。
- **xpath**：由现有 `getXPath(element)` 生成，用于日志与后续可能的 fallback 查找。
- **locatorDesc**：由现有 `formatLocator(locator)` 生成，便于调试与展示。

### 3.3 存储读写

- **key**：`chrome.storage.local.fieldMappings[cacheKey]`，值为 `{ mappings: Mapping[], cachedAt: string }`（与现有结构一致）。
- **绑定时的合并逻辑**：  
  - 用 `getCacheKey()` 得到当前页的 `cacheKey`。  
  - 读取当前缓存：`getCachedMapping(cacheKey)`（内部可先试 `cacheKey`，再试 `domain`）。  
  - 得到数组 `mappings`（无则 `[]`）。  
  - 从 `mappings` 中**移除**所有 `standardField === 本次绑定的字段` 的项。  
  - **追加**一条新映射：`{ standardField, locator, xpath, locatorDesc, method: 'bind' }`。  
  - 写回：`cacheMapping(cacheKey, mappings)`。  
  - 更新内存：`pageState.fieldMappings = mappings`，以便本次会话后续「识别并填充」立即生效。

---

## 四、实现要点（按模块）

### 4.1 Content Script（formHandler.js）

| 项 | 说明 |
|----|------|
| **cacheKey** | 新增 `getCacheKey()`：`window.location.hostname + (window.location.pathname.replace(/\/$/, '') || '/')`。 |
| **缓存读写** | `getCachedMapping(key)`、`cacheMapping(key, mappings)` 改为按 `key` 读写；读取时若 `key` 无数据可回退到 `domain`（hostname only）以兼容旧数据。 |
| **识别流程** | `recognizeForm()` 中：先 `cacheKey = getCacheKey()`，再 `getCachedMapping(cacheKey)`；无缓存时才执行 `recognizeByKeywords()`，最后 `cacheMapping(cacheKey, mappings)`。这样同一 URL 永远用同一份映射。 |
| **清除映射** | `clearMapping()` 改为按 `getCacheKey()` 清除当前页的 key；若希望「清除整个站点的所有路径」可另提供入口（如选项页）。 |
| **右键目标** | 继续使用现有 `lastContextMenuTarget`（在 `contextmenu` 时由 `getEditableElementFromTarget(e.target)` 得到）。 |
| **新 message** | 监听 `action: 'bindField'`，参数 `standardField`。处理逻辑：<br>1. 取 `lastContextMenuTarget`，若为空或不在 document 内，返回 `{ success: false, error: '请在有输入框的位置右键并选择要绑定的字段' }`。<br>2. 若元素不是 input/textarea/select/contenteditable，可仍允许绑定（因为有些站点用 div 模拟输入），用 `getFieldLocator` 时需兼容：对无 name/id 的 div 用 index 或 xpath。<br>3. `locator = getFieldLocator(el)`；若当前 `getFieldLocator` 只接受 form 内 input，需扩展：对任意可编辑元素生成 locator（例如用 xpath 或 index）。<br>4. `xpath = getXPath(el)`，`locatorDesc = formatLocator(locator)`。<br>5. `cacheKey = getCacheKey()`；`existing = await getCachedMapping(cacheKey)`；合并后 `await cacheMapping(cacheKey, newMappings)`；`pageState.fieldMappings = newMappings`。<br>6. 返回 `{ success: true, standardField, cacheKey }`。 |
| **getFieldLocator 扩展** | 当前 `getFieldLocator` 假定元素有 `name`/`id`/`dataset` 或在 form 内。对「任意可编辑元素」（如 contenteditable 的 div），若没有 id/name，应 fallback 到 `{ type: 'xpath', value: getXPath(el) }`，以便绑定仍可保存并在下次用 `findElementByLocator` 解析。 |

### 4.2 Background（background.js）

| 项 | 说明 |
|----|------|
| **新菜单** | 在现有「填充单个字段」同级增加一级菜单，例如：<br>**「绑定为字段 (外链提交助手)」**，id 如 `bind-field-parent`，contexts 同现有 `['page','editable']`。 |
| **子项** | 与现有填充字段列表一致：网站名称、联系邮箱、网站 URL、分类、标签、标语、简短描述、详细描述、Logo、界面截图；id 如 `bind_siteName`、`bind_email` 等。 |
| **点击处理** | 在 `chrome.contextMenus.onClicked` 中：若 `menuItemId` 以 `bind_` 开头，则 `standardField = menuItemId.replace(/^bind_/, '')`，向当前 tab 发送 `{ action: 'bindField', standardField }`；根据 content 返回结果可考虑在 popup 或通过 chrome.notifications 提示成功/失败（可选）。 |

### 4.3 可选：用户反馈

- **成功**：content 返回 `success: true` 后，background 或 content 可：  
  - 在页面内短暂 toaster（content 注入一条 toast），如「已绑定：网站名称」；或  
  - 仅 console.log，供调试。  
- **失败**：如「请在有输入框的位置右键」：可 content 内 `console.warn`，或通过 sendResponse 让 popup 显示错误（若当时 popup 打开）。

---

## 五、边界情况

| 情况 | 处理 |
|------|------|
| 右键不在可编辑元素上 | 返回错误提示：「请在有输入框的位置右键并选择要绑定的字段」。不写入缓存。 |
| 同一标准字段多次绑定 | 每次绑定都覆盖该页面上该标准字段的旧映射（删除旧项 + 追加新项），保证每页每标准字段仅一条。 |
| 绑定了某字段，但该页还有其它输入框未绑定 | 正常。识别/填充时只填充有映射的字段；未绑定的可依赖自动识别或用户继续绑定。 |
| 页面动态加载，DOM 后变 | locator 若为 id/name 通常仍有效；若为 index/xpath 可能失效。失效后用户再次在该输入框上右键重新绑定即可。 |
| 同一域名多路径 | 各 path 独立缓存，互不影响；例如 `/submit` 与 `/edit` 各有一份映射。 |

---

## 六、与现有流程的衔接

- **识别**：`recognizeForm()` 先查 `getCachedMapping(cacheKey)`。若有缓存（含用户绑定的映射），直接使用，不再跑 keyword 识别；若无，再 `recognizeByKeywords()` 并写入 `cacheKey`。
- **填充**：逻辑不变，仍按 `pageState.fieldMappings` 逐个 `findElementByLocator` 填充；`fieldMappings` 可来自「仅绑定」「仅识别」或「识别 + 多次绑定纠错」合并后的结果。
- **清除**：popup/选项页「清除当前页映射」调用 `clearMapping()`，content 按 `getCacheKey()` 删除当前页的缓存条目。

---

## 七、小结

- **用户侧**：在输入框上右键 → 「绑定为字段」→ 选标准字段 → 完成；同一页面再次打开即复用，无需再配。
- **实现侧**：缓存键细化为 domain + pathname；content 新增 `getCacheKey()`、`bindField` 处理与合并逻辑；background 新增「绑定为字段」菜单并转发 `bindField`；locator 由现有/扩展的 `getFieldLocator` + `getXPath` 自动生成，用户无需接触 element path。

按此设计即可实现「一次配置、后续无限复用」且「配置 element path 过程足够简单」的点选绑定流程。
