# 导航站一键识别填充设计文档（AI 识别版本）

## 一、目标与约束

- **最终体验**：用户点击一个按钮，**一键填充**当前提交页所有需要填充的字段，且**速度尽量快**（目标 3s 内完成识别+填充）。
- **填充方式**：
  - **文本类**（网站名称、邮箱、URL、描述等）：直接写入/粘贴到输入框。
  - **文件上传**（Logo、界面截图）：由插件协助完成——在支持的环境下通过 DataTransfer 等写入，否则通过「点击上传控件」打开文件选择器，由用户选择已准备好的文件或由自动化工具注入。
- **识别方式**：
  - **接入 AI**：打开页面后，用大模型理解当前页 HTML，提取需要填充的字段及其定位信息，再执行填充。

---

## 二、整体流程

| 阶段     | 步骤 | 说明 |
|----------|------|------|
| **识别** | 1. 获取页面表单结构 | 拿到当前页的 HTML / DOM / 结构化表单描述。 |
|          | 2. 得到字段映射     | 实时调 AI 得到「标准字段 → 元素定位」的映射（standardField → locator）。 |
| **填充** | 3. 按映射定位元素   | 根据 locator 在页面上找到每个输入控件。 |
|          | 4. 填充文本         | 对 input/textarea/contenteditable 等写入站点档案中的文本。 |
|          | 5. 处理文件上传     | 对 Logo/截图：能程序写入则写入，否则触发点击由用户或自动化选文件。 |

**AI 方案**中，步骤 1–2 在用户点击后实时执行（或先查缓存再决定是否调 AI），然后执行 3–5。**第一次访问某站时需调 AI 识别，之后同一页秒填**。

---

## 三、AI 识别方案：步骤、技术与取巧

### 3.1 思路简述

用户打开某个导航站提交页并点击「一键填充」时，**实时**从当前页抽取表单信息，送给**大模型**理解，让模型输出「需要填充的字段 + 定位方式」（如 id、name、XPath），再在页面内按定位执行填充。文本直接写入，文件上传通过现有 DataTransfer 或点击上传控件配合用户/自动化完成。

### 3.2 步骤拆解与技术选型

| 步骤 | 做什么 | 可选技术 | 说明 |
|------|--------|----------|------|
| **1. 抽取表单结构** | 在 content script 中拿到当前页表单的紧凑表示 | **仅序列化 form**（或主表单容器）、**限制深度与属性长度** | 输出紧凑的表单描述格式，便于送 LLM。 |
| **2. 调用大模型** | 把结构发给 LLM，要求返回「标准字段 + 定位」 | **OpenAI / 兼容 API**（现有 llmService）、**本地模型（Ollama 等）**、**结构化输出（JSON）** | 建议由 **Background** 发起请求（Content 只传序列化结果），避免 CORS；与现有 `buildLLMPrompt` / `parseLLMMapping` 对齐。 |
| **3. 解析并规范化** | 从模型输出解析出 (standardField, locator) | **JSON mode**、**正则/括号匹配** 提取 JSON | 统一成扩展内部的 locator 格式（id / name+formIndex / xpath）。 |
| **4. 缓存** | 同一 URL 再次访问时避免重复调 API | **cacheKey = domain + pathname** 存 mapping | 第二次起「识别」耗时≈0。 |
| **5. 填充** | 按映射执行填充 | 见第四节 | 文本直接写入；文件用 DataTransfer 或点击上传。 |

### 3.3 AI 方案的「取巧」方式

- **精简输入**：只送表单内 input/textarea/select + 直接关联的 label/placeholder/aria-label，去掉无关 DOM，显著减少 token 与延迟。
- **固定输出格式**：要求模型严格输出 JSON，例如 `[{"standardField":"email","selector":"#email"}]`，便于解析且减少重试。
- **先查缓存再调 AI**：每次先查 `cacheKey`；命中则直接用缓存映射，不调 API，实现「第一次 AI、后续秒填」。
- **可选：规则预筛**：先跑一遍规则识别，只有「无缓存且规则未完全匹配」时才调 AI，进一步省成本、省时间。
- **超时与降级**：AI 请求设 5–10s 超时；超时或失败时回退到规则识别，保证至少能填一部分。可对瞬时失败重试 1 次再降级。

---

## 四、填充阶段：文本 vs 文件、技术与取巧

### 4.1 文本内容：直接写入

- **做法**：对 input/textarea/contenteditable，用现有逻辑：`value` 赋值 + `input`/`change` 事件；富文本/CodeMirror/ProseMirror 等已有分支。
- **技术**：Content script 内 `fillInputElement` / `fillContentEditable`，无需额外技术。
- **取巧**：
  - **减少字段间延迟**：在保证下拉/联动稳定的前提下，把 `FILL_FIELD_DELAY_MS` 按字段类型区分（普通 input 可更短，自定义下拉/富文本略长）。
  - **批量 dispatch**：同一表单内多个简单 input 可连续赋值后再统一 dispatch 事件，减少重排次数（需验证目标站点无依赖「逐字段失焦」的逻辑）。

### 4.2 文件上传：点击上传 + 能写则写

- **现状**：扩展内已通过 **DataTransfer + File 对象**（`fillFileInputWithDataUrl`）尝试写入 `input.files`；在部分站点/浏览器下可用。
- **限制**：出于安全策略，部分环境禁止脚本直接设置 `input[type=file].files`，此时只能「帮助用户点击」。
- **可选技术**：
  - **可写时**：继续用 DataTransfer 将站点档案中的 Logo/截图（data URL 转 File）写入 file input，并触发 `input`/`change`。
  - **不可写时**：由插件**模拟点击**上传控件，打开系统文件选择器；用户从本地选择已准备好的文件，或由**外部自动化**（Playwright/Puppeteer 的 FileChooser）在非扩展环境中注入文件。
- **取巧**：
  - 优先尝试 DataTransfer；写入后检查 `input.files.length` 等以确认是否生效，未生效则立即走「点击上传」并明确提示用户选择文件。

---

## 五、整体步骤汇总

| 序号 | 阶段 | 步骤 | AI 方案 |
|------|------|------|---------|
| 1 | 识别 | 获取表单结构 | Content 序列化当前页 form |
| 2 | 识别 | 得到字段映射 | 实时调 LLM，解析出 mappings，并写入缓存 |
| 3 | 填充 | 定位元素 | 查表得到 mappings，在页面上 resolve |
| 4 | 填充 | 填文本 | 按标准字段取站点数据，写入控件 |
| 5 | 填充 | 文件上传 | DataTransfer 或点击上传 |

**步骤总数**：识别 2 步 + 填充 3 步，共 **5 步**；第一次访问某站需调 AI（约 2–5s），之后同一页秒填。

---

## 六、易用性、可维护性与实现复杂度

### 6.1 易用性

| 维度 | 设计要点 | 说明 |
|------|----------|------|
| **结果可见性** | 填充完成后给出明确反馈 | 如：「已填充 8/10 项；Logo、截图需您手动选择文件」；失败字段列出并支持「重试」或「手动填写」。 |
| **部分成功** | 支持部分字段填充成功、部分失败 | 不因单字段失败阻断整页；未识别或写入失败的字段可高亮或列在「待补全」列表，用户可手动补填。 |
| **降级说明** | 文件上传不可写时的提示 | 当 DataTransfer 不可用时，明确提示「请点击上传按钮并选择文件」，避免用户误以为未执行。 |
| **首次使用** | 可选引导 | 第一次在某站使用「一键填充」时，可简短说明「首次会识别页面（约 2–5s），之后同页将秒填」。 |
| **可覆盖** | 用户可纠正错误映射（可选） | 若某站自动把「描述」填到了错误输入框，支持用户「点选绑定字段」修正一次并写回缓存，下次优先用用户修正结果。 |

### 6.2 可维护性

| 维度 | 设计要点 | 说明 |
|------|----------|------|
| **映射表结构** | 统一 schema + 版本号 | 存储格式约定为 `{ version: 1, cacheKey, mappings: [{ standardField, locator }], updatedAt? }`，便于后续扩展字段或 locator 类型时做兼容与迁移。 |
| **缓存失效** | 页面结构变更时能更新 | 若检测到页面 DOM 与缓存中记录的表单结构差异过大（如关键 selector 失效），可自动标记该 cacheKey 失效并回退「重新识别」。 |
| **配置集中** | 延迟、超时、开关集中管理 | 将 `FILL_FIELD_DELAY_MS`、AI 超时、是否启用规则优先等收拢到单一配置（如 `fillConfig`），便于调优与开关功能。 |

### 6.3 技术实现复杂度控制

| 维度 | 设计要点 | 说明 |
|------|----------|------|
| **表单序列化格式** | 约定单一「紧凑表示」规范 | 仅 form 内 input/textarea/select + id/name/type/label/placeholder/aria-label + 顺序，便于复用 LLM prompt。 |
| **Content/Background 分工** | 抽 DOM 在 content，调 API 在 background | Content script 只负责序列化当前页 form 并接收填充指令；Background 负责查缓存、调 LLM、存缓存，避免在 content 里直接调外部 API 带来的 CORS/权限问题。 |
| **失败与重试** | AI 调用可重试、有降级 | 网络或 API 瞬时失败时，可重试 1 次；仍失败则回退规则识别并提示「本次使用规则匹配，部分字段可能需您核对」。 |
| **文件写入检测** | 明确 DataTransfer 是否生效 | 写入 file input 后检查 `input.files.length` 等；若仍为 0 则视为不可写，立即走「点击上传 + 提示用户选文件」，避免静默失败。 |

---

## 七、推荐落地顺序

- **短期**：以 **AI 方案**为主，复用现有 LLM 能力；加强「表单结构精简 + 缓存（cacheKey = domain + pathname）」和「解析失败时回退规则」，这样**一次点击即可**完成识别+填充，第二次同一页秒填。
- **取巧优先级**：
  1. **缓存**（domain + pathname）—— 识别只做一次。
  2. **精简送 LLM 的内容**—— 只送 form 内字段描述，缩短延迟与成本。
  3. **填充阶段**—— 区分字段类型缩短延迟、文件优先 DataTransfer 再点击上传。

按上述规划即可实现「点击一个按钮、一键填充所有字段、且尽量快」的目标。
